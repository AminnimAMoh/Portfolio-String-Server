{"version":3,"file":"D3-stationsClick.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC/YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://mamp-frontend/./txsrc/views/Pages/D3/ExternalResource/RadarChart.js","webpack://mamp-frontend/./txsrc/views/Pages/D3/MapComponents/PopulationCircles.js","webpack://mamp-frontend/./txsrc/views/Pages/D3/MapMouseControles/StationsClick.js"],"sourcesContent":["/////////////////////////////////////////////////////////\r\n/////////////// The Radar Chart Function ////////////////\r\n/// mthh - 2017 /////////////////////////////////////////\r\n// Inspired by the code of alangrafu and Nadieh Bremer //\r\n// (VisualCinnamon.com) and modified for d3 v4 //////////\r\n/////////////////////////////////////////////////////////\r\nimport * as d3 from \"d3\";\r\n\r\nconst max = Math.max;\r\nconst sin = Math.sin;\r\nconst cos = Math.cos;\r\nconst HALF_PI = Math.PI / 2;\r\n\r\nconst RadarChart = function RadarChart(parent_selector, data, options) {\r\n  //Wraps SVG text - Taken from http://bl.ocks.org/mbostock/7555321\r\n  const wrap = (text, width) => {\r\n    text.each(function () {\r\n      var text = d3.select(this),\r\n        words = text.text().split(/\\s+/).reverse(),\r\n        word,\r\n        line = [],\r\n        lineNumber = 0,\r\n        lineHeight = 1.4, // ems\r\n        y = text.attr(\"y\"),\r\n        x = text.attr(\"x\"),\r\n        dy = parseFloat(text.attr(\"dy\")),\r\n        tspan = text\r\n          .text(null)\r\n          .append(\"tspan\")\r\n          .attr(\"x\", x)\r\n          .attr(\"y\", y)\r\n          .attr(\"dy\", dy + \"em\");\r\n\r\n      while ((word = words.pop())) {\r\n        line.push(word);\r\n        tspan.text(line.join(\" \"));\r\n        if (tspan.node().getComputedTextLength() > width) {\r\n          line.pop();\r\n          tspan.text(line.join(\" \"));\r\n          line = [word];\r\n          tspan = text\r\n            .append(\"tspan\")\r\n            .attr(\"x\", x)\r\n            .attr(\"y\", y)\r\n            .attr(\"dy\", ++lineNumber * lineHeight + dy + \"em\")\r\n            .text(word);\r\n        }\r\n      }\r\n    });\r\n  }; //wrap\r\n\r\n  const cfg = {\r\n    w: 600, //Width of the circle\r\n    h: 600, //Height of the circle\r\n    margin: {\r\n      top: 20,\r\n      right: 20,\r\n      bottom: 20,\r\n      left: 20,\r\n    }, //The margins of the SVG\r\n    levels: 3, //How many levels or inner circles should there be drawn\r\n    maxValue: 0, //What is the value that the biggest circle will represent\r\n    labelFactor: 1.55, //How much farther than the radius of the outer circle should the labels be placed\r\n    wrapWidth: 60, //The number of pixels after which a label needs to be given a new line\r\n    opacityArea: 0.8, //The opacity of the area of the blob\r\n    dotRadius: 2, //The size of the colored circles of each blog\r\n    opacityCircles: 1, //The opacity of the circles of each blob\r\n    strokeWidth: 0.8, //The width of the stroke around each blob\r\n    roundStrokes: false, //If true the area and stroke will follow a round path (cardinal-closed)\r\n    color: d3.scaleOrdinal(d3.schemeCategory10), //Color function,\r\n    format: \".2%\",\r\n    unit: \"mm\",\r\n    legend: false,\r\n  };\r\n\r\n  //Put all of the options into a variable called cfg\r\n  if (\"undefined\" !== typeof options) {\r\n    for (var i in options) {\r\n      if (\"undefined\" !== typeof options[i]) {\r\n        cfg[i] = options[i];\r\n      }\r\n    } //for i\r\n  } //if\r\n\r\n  //If the supplied maxValue is smaller than the actual one, replace by the max in the data\r\n  // var maxValue = max(cfg.maxValue, d3.max(data, function(i){return d3.max(i.map(function(o){return o.value;}))}));\r\n  let maxValue = 0;\r\n  //   for (let j = 0; j < data.length; j++) {\r\n  for (let i = 0; i < data.axes.length; i++) {\r\n    data.axes[i][\"id\"] = data.name;\r\n    if (data.axes[i][\"value\"] > maxValue) {\r\n      maxValue = data.axes[i][\"value\"];\r\n    }\r\n    // }\r\n  }\r\n  maxValue = max(cfg.maxValue, maxValue);\r\n\r\n  const allAxis = data.axes.map((i, j) => i.axis), //Names of each axis\r\n    total = allAxis.length, //The number of different axes\r\n    radius = Math.min(cfg.w / 2, cfg.h / 2), //Radius of the outermost circle\r\n    Format = d3.format(cfg.format), //Formatting\r\n    angleSlice = (Math.PI * 2) / total; //The width in radians of each \"slice\"\r\n\r\n  //Scale for the radius\r\n  const rScale = d3.scaleLinear().range([0, radius]).domain([0, maxValue]);\r\n\r\n  /////////////////////////////////////////////////////////\r\n  //////////// Create the container SVG and g /////////////\r\n  /////////////////////////////////////////////////////////\r\n  const parent = d3.select(parent_selector);\r\n\r\n  //Remove whatever chart with the same id/class was present before\r\n  parent.select(\"svg\").remove();\r\n\r\n  //Initiate the radar chart SVG\r\n  let svg = parent\r\n    .append(\"svg\")\r\n    .attr(\"width\", cfg.w + cfg.margin.left + cfg.margin.right)\r\n    .attr(\"height\", cfg.h + cfg.margin.top + cfg.margin.bottom)\r\n    .attr(\"class\", \"radar\");\r\n\r\n  //Append a g element\r\n  let g = svg\r\n    .append(\"g\")\r\n    .attr(\r\n      \"transform\",\r\n      \"translate(\" +\r\n        (cfg.w / 2 + cfg.margin.left) +\r\n        \",\" +\r\n        (cfg.h / 2 + cfg.margin.top) +\r\n        \")\"\r\n    );\r\n\r\n  /////////////////////////////////////////////////////////\r\n  ////////// Glow filter for some extra pizzazz ///////////\r\n  /////////////////////////////////////////////////////////\r\n\r\n  //Filter for the outside glow\r\n  let filter = g.append(\"defs\").append(\"filter\").attr(\"id\", \"glow\");\r\n  filter.append(\"feGaussianBlur\")\r\n      .attr(\"stdDeviation\", \"2.5\")\r\n      .attr(\"result\", \"coloredBlur\");\r\n  let feMerge = filter.append(\"feMerge\");\r\n  feMerge.append(\"feMergeNode\").attr(\"in\", \"coloredBlur\");\r\n  feMerge.append(\"feMergeNode\").attr(\"in\", \"SourceGraphic\");\r\n\r\n  /////////////////////////////////////////////////////////\r\n  /////////////// Draw the Circular grid //////////////////\r\n  /////////////////////////////////////////////////////////\r\n\r\n  //Wrapper for the grid & axes\r\n  let axisGrid = g.append(\"g\").attr(\"class\", \"axisWrapper\");\r\n\r\n  //Draw the background circles\r\n  axisGrid\r\n    .selectAll(\".levels\")\r\n    .data(d3.range(1, cfg.levels + 1).reverse())\r\n    .enter()\r\n    .append(\"circle\")\r\n    .attr(\"class\", \"gridCircle\")\r\n    .attr(\"r\", (d) => (radius / cfg.levels) * d)\r\n    .style(\"fill\", \"#CDCDCD\")\r\n    .style(\"stroke\", \"#CDCDCD\")\r\n    .style(\"fill-opacity\", cfg.opacityCircles)\r\n    .style(\"filter\", \"url(#glow)\");\r\n\r\n  //Text indicating at what % each level is\r\n  axisGrid\r\n    .selectAll(\".axisLabel\")\r\n    .data(d3.range(1, cfg.levels + 1).reverse())\r\n    .enter()\r\n    .append(\"text\")\r\n    .attr(\"class\", \"axisLabel\")\r\n    .attr(\"x\", 4)\r\n    .attr(\"y\", (d) => (-d * radius) / cfg.levels)\r\n    .attr(\"dy\", \"0.4em\")\r\n    .style(\"font-size\", \"10px\")\r\n    .attr(\"fill\", \"#737373\")\r\n    .text((d) => Format((maxValue * d) / cfg.levels) + cfg.unit);\r\n\r\n  /////////////////////////////////////////////////////////\r\n  //////////////////// Draw the axes //////////////////////\r\n  /////////////////////////////////////////////////////////\r\n\r\n  //Create the straight lines radiating outward from the center\r\n  var axis = axisGrid\r\n    .selectAll(\".axis\")\r\n    .data(allAxis)\r\n    .enter()\r\n    .append(\"g\")\r\n    .attr(\"class\", \"axis\");\r\n  //Append the lines\r\n  axis\r\n    .append(\"line\")\r\n    .attr(\"x1\", 0)\r\n    .attr(\"y1\", 0)\r\n    .attr(\r\n      \"x2\",\r\n      (d, i) => rScale(maxValue * 1.1) * cos(angleSlice * i - HALF_PI)\r\n    )\r\n    .attr(\r\n      \"y2\",\r\n      (d, i) => rScale(maxValue * 1.1) * sin(angleSlice * i - HALF_PI)\r\n    )\r\n    .attr(\"class\", \"line\")\r\n    .style(\"stroke\", \"white\")\r\n    .style(\"stroke-width\", \"2px\");\r\n\r\n  //Append the labels at each axis\r\n  axis\r\n    .append(\"text\")\r\n    .attr(\"class\", \"legend\")\r\n    .style(\"font-size\", \"8px\")\r\n    .attr(\"text-anchor\", \"middle\")\r\n    .attr(\"dy\", \"0.35em\")\r\n    .attr(\r\n      \"x\",\r\n      (d, i) =>\r\n        rScale(maxValue * cfg.labelFactor) * cos(angleSlice * i - HALF_PI)\r\n    )\r\n    .attr(\r\n      \"y\",\r\n      (d, i) =>\r\n        rScale(maxValue * cfg.labelFactor) * sin(angleSlice * i - HALF_PI)\r\n    )\r\n    .text((d) => d)\r\n    .call(wrap, cfg.wrapWidth);\r\n\r\n  //The radial line function\r\n  var radarLine = d3\r\n    .radialLine()\r\n    .curve(d3.curveLinearClosed)\r\n    .radius((d) => rScale(d.value))\r\n    .angle((d, i) => {return i * angleSlice});\r\n\r\n  if (cfg.roundStrokes) {\r\n    radarLine.curve(d3.curveCardinalClosed);\r\n  }\r\n\r\n  //Create a wrapper for the blobs\r\n  var blobWrapper = g\r\n    .selectAll(\".radarWrapper\")\r\n    .data(data)\r\n    .enter()\r\n    .append(\"g\")\r\n    .attr(\"class\", \"radarWrapper\");\r\n\r\n  //Append the backgrounds\r\n  blobWrapper\r\n    .append(\"path\")\r\n    .attr(\"class\", \"radarArea\")\r\n    .attr(\"d\", (d) => radarLine(d.axes))\r\n    .style(\"fill\", (d, i) => cfg.color(i))\r\n    .style(\"fill-opacity\", cfg.opacityArea)\r\n    .on(\"mouseover\", function (d, i) {\r\n      //Dim all blobs\r\n      parent\r\n        .selectAll(\".radarArea\")\r\n        .transition()\r\n        .duration(200)\r\n        .style(\"fill-opacity\", 0.1);\r\n      //Bring back the hovered over blob\r\n      d3.select(this).transition().duration(200).style(\"fill-opacity\", 0.7);\r\n    })\r\n    .on(\"mouseout\", () => {\r\n      //Bring back all blobs\r\n      parent\r\n        .selectAll(\".radarArea\")\r\n        .transition()\r\n        .duration(200)\r\n        .style(\"fill-opacity\", cfg.opacityArea);\r\n    });\r\n\r\n  //Create the outlines\r\n  blobWrapper\r\n    .append(\"path\")\r\n    .attr(\"class\", \"radarStroke\")\r\n    .attr(\"d\", function (d, i) {\r\n      return radarLine(d.axes);\r\n    })\r\n    .style(\"stroke-width\", cfg.strokeWidth + \"px\")\r\n    .style(\"stroke\", (d, i) => cfg.color(i))\r\n    .style(\"fill\", \"none\")\r\n    .style(\"filter\", \"url(#glow)\");\r\n\r\n  //Append the circles\r\n  blobWrapper\r\n    .selectAll(\".radarCircle\")\r\n    .data((d) => d.axes)\r\n    .enter()\r\n    .append(\"circle\")\r\n    .attr(\"class\", \"radarCircle\")\r\n    .attr(\"r\", cfg.dotRadius)\r\n    .attr(\"cx\", (d, i) => {\r\n      return rScale(d.value) * cos(angleSlice * i - HALF_PI);\r\n    })\r\n    .attr(\"cy\", (d, i) => {\r\n      return rScale(d.value) * sin(angleSlice * i - HALF_PI);\r\n    })\r\n    .style(\"fill\", (d) => cfg.color(d.id))\r\n    .style(\"fill-opacity\", 0.8);\r\n\r\n  /////////////////////////////////////////////////////////\r\n  //////// Append invisible circles for tooltip ///////////\r\n  /////////////////////////////////////////////////////////\r\n\r\n  //Wrapper for the invisible circles on top\r\n  var blobCircleWrapper = g\r\n    .selectAll(\".radarCircleWrapper\")\r\n    .data(data)\r\n    .enter()\r\n    .append(\"g\")\r\n    .attr(\"class\", \"radarCircleWrapper\");\r\n\r\n  //Append a set of invisible circles on top for the mouseover pop-up\r\n  blobCircleWrapper\r\n    .selectAll(\".radarInvisibleCircle\")\r\n    .data((d) => d.axes)\r\n    .enter()\r\n    .append(\"circle\")\r\n    .attr(\"class\", \"radarInvisibleCircle\")\r\n    .attr(\"r\", cfg.dotRadius * 1.5)\r\n    .attr(\"cx\", (d, i) => rScale(d.value) * cos(angleSlice * i - HALF_PI))\r\n    .attr(\"cy\", (d, i) => rScale(d.value) * sin(angleSlice * i - HALF_PI))\r\n    .style(\"fill\", \"none\")\r\n    .style(\"pointer-events\", \"all\")\r\n    .on(\"mouseover\", function (d, i) {\r\n      tooltip\r\n        .attr(\"x\", this.cx.baseVal.value - 10)\r\n        .attr(\"y\", this.cy.baseVal.value - 10)\r\n        .transition()\r\n        .style(\"display\", \"block\")\r\n        .text(Format(d.value) + cfg.unit);\r\n    })\r\n    .on(\"mouseout\", function () {\r\n      tooltip.transition().style(\"display\", \"none\").text(\"\");\r\n    });\r\n\r\n  const tooltip = g\r\n    .append(\"text\")\r\n    .attr(\"class\", \"tooltip\")\r\n    .attr(\"x\", 0)\r\n    .attr(\"y\", 0)\r\n    .style(\"font-size\", \"12px\")\r\n    .style(\"display\", \"none\")\r\n    .attr(\"text-anchor\", \"middle\")\r\n    .attr(\"dy\", \"0.35em\");\r\n\r\n  if (cfg.legend !== false && typeof cfg.legend === \"object\") {\r\n    let legendZone = svg.append(\"g\");\r\n    let names = data.map((el) => el.name);\r\n    if (cfg.legend.title) {\r\n      legendZone\r\n        .append(\"text\")\r\n        .attr(\"class\", \"title\")\r\n        .attr(\r\n          \"transform\",\r\n          `translate(${cfg.legend.translateX},${cfg.legend.translateY})`\r\n        )\r\n        .attr(\"x\", cfg.w - 70)\r\n        .attr(\"y\", 10)\r\n        .attr(\"font-size\", \"12px\")\r\n        .attr(\"fill\", \"#404040\")\r\n        .text(cfg.legend.title);\r\n    }\r\n    let legend = legendZone\r\n      .append(\"g\")\r\n      .attr(\"class\", \"legend\")\r\n      .attr(\"height\", 100)\r\n      .attr(\"width\", 200)\r\n      .attr(\r\n        \"transform\",\r\n        `translate(${cfg.legend.translateX},${cfg.legend.translateY + 20})`\r\n      );\r\n    // Create rectangles markers\r\n    legend\r\n      .selectAll(\"rect\")\r\n      .data(names)\r\n      .enter()\r\n      .append(\"rect\")\r\n      .attr(\"x\", cfg.w - 65)\r\n      .attr(\"y\", (d, i) => i * 20)\r\n      .attr(\"width\", 10)\r\n      .attr(\"height\", 10)\r\n      .style(\"fill\", (d, i) => cfg.color(i));\r\n    // Create labels\r\n    legend\r\n      .selectAll(\"text\")\r\n      .data(names)\r\n      .enter()\r\n      .append(\"text\")\r\n      .attr(\"x\", cfg.w - 52)\r\n      .attr(\"y\", (d, i) => i * 20 + 9)\r\n      .attr(\"font-size\", \"11px\")\r\n      .attr(\"fill\", \"#737373\")\r\n      .text((d) => d);\r\n  }\r\n  return svg;\r\n};\r\nexport default RadarChart;\r\n","const PopulationCircles = (\r\n  population,\r\n  groupOne,\r\n  groupTwo,\r\n  groupThree,\r\n  mapXOffSet,\r\n  coords,\r\n  graphRad,\r\n  lables,\r\n  d3,\r\n  nameOfCity,\r\n  angleScale,\r\n  rectsLength\r\n) => {\r\n  const arcGenerator = d3\r\n    .arc()\r\n    .innerRadius(60)\r\n    .outerRadius(function (d) {\r\n      return outer(d.data);\r\n    });\r\n\r\n  const outer = d3\r\n    .scaleLinear()\r\n    .domain([+population.data[0].Min2011, +population.data[0].Max2011])\r\n    .range([62, 70]);\r\n\r\n  const pieColorScale = d3\r\n    .scaleSequential()\r\n    .domain([+population.data[0].Min1991, +population.data[0].Max1991])\r\n    .interpolator(d3.interpolateBuPu);\r\n\r\n  const popCityName = population.data.map((data) => {\r\n    return data.City;\r\n  });\r\n\r\n  let populations = {\r\n    popOne: 0,\r\n    popTwo: 0,\r\n    popThree: 0,\r\n  };\r\n  for (let i = 0; i < 3; i++) {\r\n    let data;\r\n    let groupContainer;\r\n\r\n    if (i === 0) {\r\n      data = population.data.map((data) => {\r\n        return +data.Population1991;\r\n      });\r\n      groupContainer = groupOne;\r\n    } else if (i === 1) {\r\n      data = population.data.map((data) => {\r\n        return +data.Population2001;\r\n      });\r\n      groupContainer = groupTwo;\r\n    } else if (i === 2) {\r\n      data = population.data.map((data) => {\r\n        return +data.Population2011;\r\n      });\r\n      groupContainer = groupThree;\r\n    }\r\n    data.splice(0, 2);\r\n    const popScale = d3.pie()(data);\r\n    const populationOne = population.data.map((data) => {\r\n      return +data.Population1991;\r\n    });\r\n    const cOne = groupContainer.selectAll(\"path\").data(populationOne);\r\n    cOne.exit().remove();\r\n\r\n    cOne\r\n      .select(\"path\")\r\n      .data(popScale)\r\n      .enter()\r\n      .append(\"path\")\r\n      .attr(\"d\", arcGenerator)\r\n      .style(\"fill\", function (d, i) {\r\n        if (nameOfCity === popCityName[i]) {\r\n          populations.popOne = population.data[i].Population1991;\r\n          populations.popTwo = population.data[i].Population2001;\r\n          populations.popThree = population.data[i].Population2011;\r\n          return \"#9C3C41\";\r\n        } else {\r\n          return pieColorScale(data[i]);\r\n        }\r\n      })\r\n      .style(\"stroke-width\", \"none\")\r\n      .transition()\r\n      .ease(d3.easePoly)\r\n      .duration(1000)\r\n      .attrTween(\"d\", arcTween);\r\n\r\n    const groupTx = mapXOffSet + coords[0] + graphRad * Math.cos(angleScale(i));\r\n    const groupTy = coords[1] + graphRad * Math.sin(angleScale(i));\r\n\r\n    groupContainer.attr(\r\n      \"transform\",\r\n      \"translate(\" + groupTx + \",\" + groupTy + \")\"\r\n    );\r\n    function arcTween(d) {\r\n      const i = d3.interpolateNumber(70, 60);\r\n      return function (t) {\r\n        const r = i(t),\r\n          arc = d3\r\n            .arc()\r\n            .outerRadius(function (d) {\r\n              return outer(d.data);\r\n            })\r\n            .innerRadius(r);\r\n        return arc(d);\r\n      };\r\n    }\r\n\r\n    lables.attr(\r\n      \"transform\",\r\n      \"translate(\" + (groupTx + 110) + \",\" + groupTy + \")\"\r\n    );\r\n\r\n    let textContainer = lables.selectAll(\"text\").data(rectsLength);\r\n    let formatComma = d3.format(\",\");\r\n    textContainer.exit().remove();\r\n\r\n    textContainer\r\n      .select(\"text\")\r\n      .data(rectsLength)\r\n      .enter()\r\n      .append(\"text\")\r\n      .attr(\"x\", function (d) {\r\n        return d.x;\r\n      })\r\n      .attr(\"y\", function (d) {\r\n        return d.y + 5;\r\n      })\r\n      .text(function (d) {\r\n        return d.text;\r\n      })\r\n      .attr(\"width\", 20)\r\n      .attr(\"fill\", \"#B0B2B8\")\r\n      .attr(\"font-size\", 11)\r\n      .style(\"opacity\", 1);\r\n\r\n    textContainer\r\n      .select(\"text\")\r\n      .data(rectsLength)\r\n      .enter()\r\n      .append(\"text\")\r\n      .attr(\"x\", function (d) {\r\n        if (\r\n          formatComma(populations.popOne) === \"NaN\" ||\r\n          formatComma(populations.popTwo) === \"NaN\" ||\r\n          formatComma(populations.popThree) === \"NaN\"\r\n        ) {\r\n          return d.x - 20;\r\n        } else {\r\n          return d.x - 28;\r\n        }\r\n      })\r\n      .attr(\"y\", function (d) {\r\n        return d.y + 25;\r\n      })\r\n      .text(function (d, i) {\r\n        switch (i) {\r\n          case 0:\r\n            if (formatComma(populations.popOne) === \"NaN\") {\r\n              return \"Data Missing\";\r\n            }\r\n            return formatComma(populations.popOne);\r\n          case 1:\r\n            if (formatComma(populations.popTwo) === \"NaN\") {\r\n              return \"Data Missing\";\r\n            }\r\n            return formatComma(populations.popTwo);\r\n          case 2:\r\n            if (formatComma(populations.popThree) === \"NaN\") {\r\n              return \"Data Missing\";\r\n            }\r\n            return formatComma(populations.popThree);\r\n          default:\r\n            return formatComma(0);\r\n        }\r\n      })\r\n      .attr(\"width\", 20)\r\n      .style(\"fill\", \"#E4E5E7\")\r\n      .style(\"font-size\", 11);\r\n  }\r\n};\r\nexport default PopulationCircles;\r\n","import { staticState } from \"../data/staticVariables\";\r\nimport { angleScale } from \"../utilities\";\r\nimport PopulationCircles from \"../MapComponents/PopulationCircles\";\r\nimport RadarChartEngin from '../ExternalResource/RadarChart'\r\n\r\nconst stationsClick = (\r\n  population,\r\n  months,\r\n  yearSelected,\r\n  generatedGroups,\r\n  d3,\r\n  mapXOffSet,\r\n  selected\r\n) => {\r\n  const cityLables = generatedGroups.cityLables;\r\n  const ellipseContainer = generatedGroups.ellipseContainer;\r\n  const groupOne = generatedGroups.groupOne;\r\n  const groupTwo = generatedGroups.groupTwo;\r\n  const groupThree = generatedGroups.groupThree;\r\n  const lables = generatedGroups.lables;\r\n  const rainGroup = generatedGroups.rainGroup;\r\n\r\n  const graphRad = 120;\r\n  const coords = [\r\n    selected.transform.animVal[0].matrix.e,\r\n    selected.transform.animVal[0].matrix.f,\r\n  ];\r\n  let nameOfCity = selected.id;\r\n\r\n  cityLables.selectAll(\"text\").remove();\r\n\r\n  d3.selectAll(\"circle\").classed(\"clicked\", false);\r\n  d3.select(selected).classed(\"clicked\", true);\r\n\r\n  let circleTransition = d3.transition().ease(d3.easePoly).duration(1000);\r\n\r\n  d3.transition().ease(d3.easePoly).duration(1000);\r\n\r\n  let ellipses = ellipseContainer\r\n    .selectAll(\"ellipse\")\r\n    .data(staticState.ellipsesLength);\r\n  ellipses.exit().remove();\r\n\r\n  ellipses\r\n    .select(\"ellipse\")\r\n    .data(staticState.ellipsesLength)\r\n    .enter()\r\n    .append(\"ellipse\")\r\n    .attr(\"class\", \"ellipseCan\")\r\n    .attr(\"cx\", function (d, i) {\r\n      return coords[0] + graphRad * Math.cos(angleScale(i));\r\n    })\r\n    .attr(\"cy\", function (d, i) {\r\n      return coords[1] + graphRad * Math.sin(angleScale(i));\r\n    })\r\n    .transition(circleTransition)\r\n    .attr(\"rx\", function (d) {\r\n      return d.size;\r\n    })\r\n    .attr(\"ry\", function (d) {\r\n      return d.size;\r\n    })\r\n    .attr(\"fill\", \"#061621\")\r\n    .style(\"stroke\", function (d) {\r\n      if (d.f === \"none\") {\r\n        return d.s;\r\n      } else {\r\n        return \"url(#Gradient)\";\r\n      }\r\n    })\r\n    .style(\"stroke-width\", \"1.5px\")\r\n    .style(\"filter\", \"url(#graph-drop-shadow)\");\r\n\r\n  cityLables\r\n    .selectAll(\"text\")\r\n    .data(staticState.ellipsesLength)\r\n    .enter()\r\n    .append(\"text\")\r\n    .attr(\"x\", function (d, i) {\r\n      return coords[0] + graphRad * Math.cos(angleScale(i));\r\n    })\r\n    .attr(\"y\", function (d, i) {\r\n      return coords[1] + graphRad * Math.sin(angleScale(i)) - 20;\r\n    })\r\n    .text(function (d, i) {\r\n      if (i <= 2) {\r\n        return nameOfCity;\r\n      }\r\n    })\r\n    .attr(\"text-anchor\", \"middle\")\r\n    .style(\"fill\", \"#9c3c41\")\r\n    .style(\"font-size\", \"8pt\");\r\n\r\n  d3.scaleLinear().domain([0, 63]).range([70, 0]);\r\n\r\n  PopulationCircles(\r\n    population,\r\n    groupOne,\r\n    groupTwo,\r\n    groupThree,\r\n    mapXOffSet,\r\n    coords,\r\n    graphRad,\r\n    lables,\r\n    d3,\r\n    nameOfCity,\r\n    angleScale,\r\n    staticState.rectsLength\r\n  );\r\n\r\n  let rainGroupTx =\r\n    mapXOffSet + coords[0] + graphRad * Math.cos(angleScale(3)) - 125;\r\n  let rainGroupTy = coords[1] + graphRad * Math.sin(angleScale(3)) - 125;\r\n\r\n  rainGroup\r\n    .attr(\"transform\", \"translate(\" + rainGroupTx + \",\" + rainGroupTy + \")\")\r\n    .style(\"opacity\", 1);\r\n\r\n  let margin = {\r\n      top: 50,\r\n      right: 80,\r\n      bottom: 50,\r\n      left: 80,\r\n    };\r\n    // width = Math.min(700, window.innerWidth / 4) - margin.left - margin.right;\r\n    // height = Math.min(width, window.innerHeight - margin.top - margin.bottom);\r\n\r\n  let thisCityRain = {\r\n    color: \"#cd1d27\",\r\n    name: nameOfCity,\r\n    axes: [{}],\r\n  };\r\n  months.data.map((d, i) => {\r\n    d.Station === nameOfCity &&\r\n      thisCityRain.axes.push({\r\n        value: +d[`MonthlyTotal${yearSelected}`],\r\n        axis: staticState.rainMonthsName[i % 12].name,\r\n      });\r\n      return null;\r\n  });\r\n  thisCityRain.axes.splice(0, 1);\r\n  const radarChartOptions = {\r\n    w: 90,\r\n    h: 150,\r\n    margin: margin,\r\n    levels: 2,\r\n    roundStrokes: false,\r\n    color: d3.scaleOrdinal().range([\"#9C3C41\", \"#12393D\", \"#9C3C41\"]),\r\n    format: '.1f'\r\n  };\r\n  RadarChartEngin(\".rainG\", thisCityRain, radarChartOptions);\r\n};\r\n\r\nexport default stationsClick;\r\n"],"names":[],"sourceRoot":""}